# docker-compose.production.yml
# Docker Compose for Production Deployment
# Use this for Azure Container Instances or Kubernetes deployment

version: '3.8'

services:
  # Azure Functions App - Production
  functions-app:
    image: ${DOCKER_REGISTRY}/confluence-qa-functions:${VERSION:-latest}
    container_name: confluence-qa-functions-prod
    ports:
      - "80:80"
    environment:
      # Use Azure Managed Identity in production
      - AZURE_CLIENT_ID=${AZURE_CLIENT_ID}
      
      # Connection strings (use Key Vault references in production)
      - AzureWebJobsStorage=@Microsoft.KeyVault(SecretUri=${KEY_VAULT_URI}/secrets/AzureWebJobsStorage/)
      - COSMOS_DB_CONNECTION_STRING=@Microsoft.KeyVault(SecretUri=${KEY_VAULT_URI}/secrets/CosmosDBConnectionString/)
      
      # Function Runtime Settings
      - FUNCTIONS_WORKER_RUNTIME=python
      - FUNCTIONS_EXTENSION_VERSION=~4
      - WEBSITE_RUN_FROM_PACKAGE=1
      
      # Application Insights
      - APPINSIGHTS_INSTRUMENTATIONKEY=${APPINSIGHTS_INSTRUMENTATIONKEY}
      - APPLICATIONINSIGHTS_CONNECTION_STRING=${APPLICATIONINSIGHTS_CONNECTION_STRING}
      
      # Feature Flags
      - ENABLE_RESPONSE_CACHE=true
      - ENABLE_DISTRIBUTED_TRACING=true
      
    deploy:
      replicas: 3
      resources:
        limits:
          cpus: '2'
          memory: 4G
        reservations:
          cpus: '1'
          memory: 2G
      restart_policy:
        condition: on-failure
        delay: 5s
        max_attempts: 3
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:80/api/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s
    logging:
      driver: "json-file"
      options:
        max-size: "10m"
        max-file: "3"

# For production, you typically wouldn't use docker-compose
# Instead, use:
# 1. Azure Functions Premium/Dedicated Plan
# 2. Azure Container Instances with deployment YAML
# 3. Azure Kubernetes Service (AKS) with Helm charts